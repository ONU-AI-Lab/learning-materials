---
id: python-loops
title: Циклы for и while
sidebar_label: Циклы и их особенности
---

Практически любой язык программирования содержит вложенные конструкции **цикла**, причём в большинстве случаев таких конструкций несколько.  **Циклы** необходимы, если нам надо что-либо сделать множество раз, реализовать последовательность одинаковых действий. Речь идёт о выполнении какой-нибудь операции либо списков операций снова и снова. **Циклы** максимально упрощают этот процесс. Если говорить о вышеназванных **циклах**, то **цикл** for многие считают более популярным. С него и начнём.

Начнем с самого простого, но не менее интересной конструкции в языке Python - цикл `while`. 

## Цикл while
Цикл while хорошо использовать для повторений частей кода. Здесь вместо зацикливания n-е количество раз цикл будет работать, **пока не исполнится определённое условие**:
```python
i = 0
while i < 5:
    print('Hello world')
    i += 1
```
Данный код будет исполняться до тех пор, пока переменная `i` меньше 5.

После ключевого слова `while` указывается условное выражение, и пока это выражение возвращает значение `True`, будет выполняться блок инструкций, который идет далее.

Все инструкции, которые относятся к циклу `while`, располагаются на последующих строках и должны иметь отступ от начала строки.

Чтобы лучше освоить такую конструкцию, давайте посчитаем факториал числа. Ничего страшного тут нет, факториал так факториал. А что это такое? `Факториал` - это последовательность натуральных `неотрицательных` чисел.

```python
choice = "y"
 
while choice.lower() == "y":
    print("Привет")
    choice = input("Для продолжения нажмите Y, а для выхода любую другую клавишу: ")
print("Работа программы завершена")
```

В данном случае цикл `while` будет продолжаться, пока переменная choice содержит латинскую букву `Y` или `y`.

Сам блок цикла состоит из двух инструкций. Сначала выводится сообщение "Привет", а потом вводится новое значение для переменной `choice`. И если пользователь нажмет какую-то другую клавишу, отличную от `Y`, произойдет выход из цикла, так как условие `choice.lower() == "y"` вернет значение `False`. Каждый такой проход цикла называется итерацией.

Также обратите внимание, что последняя инструкция `print("Работа программы завершена")` не имеет отступов от начала строки, поэтому она не входит в цикл `while`.

## Цикл for
Как было сказано выше, использование цикла целесообразно, если нужно повторить действие `n`-ное количество раз, выполнить некую последовательность одних и тех же операций. Рассмотрим это на примере. Возьмём встроенную в Python 3 функцию range, которая создаёт список длиной в `n` элементов.
```python
print(range(5))
```

```python
a = range(5, 10)
print(a) # range(5, 10)
b = list(range(1, 10, 2))
print(b) # [1, 3, 5, 7, 9]
```

В первом примере мы передаём начальное и конечное значение, при этом `range` возвращает список из чисел последовательности, начиная с начального, заканчивая последним (но не включая последний). Таким образом, при запросе 5-10 мы получаем 5-9 в прямом, а не обратном порядке.
Во 2-м случае используем функцию списка `list`. В результате возвращается каждый 2-й элемент между 1-10 (наша последовательность будет равна 1, 3 и т. п., разумеется, также в прямом, а не обратном порядке).
Закономерный вопрос: а что функция `range` будет делать с использованием цикла? Давайте посмотрим:
```python
for number in range(5):
    print(number)
```
Что в данном случае произошло? Чтобы понять это, расшифруем наш код: 
1. Мы вводим число для каждого числа в диапазоне 5. 

2. Мы знаем, что при вызове `range` со значением 5 будет создан вложенный список из пяти элементов. 

3. Каждый раз функция, проходя через цикл for, выведет каждый из этих элементов по списку.

## Что ещё «умеет» цикл for?
Цикл for способен обходить любой итератор Python. Мы видели особенности действия цикла при обработке списка и последовательности. А теперь взглянем, можно ли его использовать для выполнения итерации со словарём:
```python
a_dict = {"one":1, "two":2, "three":3}
for key in a_dict:
    print(key)
```
Если использовать `for` в словаре, легко заметить, что он перебирает ключи автоматически. К примеру, не нужно указывать `for a_dict.keys()` (хотя это тоже работает). Python делает только то, что необходимо. Да, ключи выводятся в несколько другом порядке, который отличен от указанного в словаре. Однако словари не упорядочены, поэтому можно использовать итерацию над ними, а ключи при этом м. б. в любом порядке. Если вы знаете, что ключи можно отсортировать, это лучше сделать до итерации. Чтобы увидеть, как это работает, немного изменим словарь:
```python
a_dict = {1:"one", 2:"two", 3:"three"}
keys = a_dict.keys()
keys = sorted(keys)
for key in keys:
    print(key)
```
Давайте разберём код данного цикла `for` подробнее. Во-первых, был создан словарь, где ключи выступают вместо строк в качестве целых чисел. Во-вторых, мы извлекли из словаря ключи. Каждый раз при вызове метода `keys()`, он возвращает нам неупорядоченный список ключей. И если при выводе списка мы видим, что они находятся в прямом либо обратном порядке, это просто случайность.
Итак, получен доступ к ключам, хранимым в keys. Мы сортируем список, после чего нужно использовать цикл for в нём. Чтобы сделать процесс интереснее, попробуем использовать цикл for в функции `range`, однако для этого потребуется вывести лишь целые числа. Дабы это осуществить, придётся использовать условный оператор, а не параметр шага `range`, что делается так:

```python
for number in range(10):
    if number % 2 == 0:
        print(number)
```

Возможно, не все поняли, что происходит и откуда в цикле знак процента. Если кто подзабыл, в Python, `%` — это оператор модуля. Когда его используют, возвращается остаток. При делении целого числа на 2, остатка, разумеется, нет.